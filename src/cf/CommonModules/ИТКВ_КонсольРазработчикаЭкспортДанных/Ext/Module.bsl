#Область ПрограммныйИнтерфейс

// Читает данные файла DCR из временного хранилища и помещает в иерархический массив структур
//  формат представляет из себя текстовый файл со строкой ЗначениеВнутр в котором хранится ДеревоЗначений
//	Колонки: Данные, Имя, ТипСтроки. Все хранится к корневом элементе Отчеты
//
// Параметры:
//   АдресХранилища - Строка - Адрес временного хранилища содержащего данные 
//   УникальныйИдентификатор - УникальныйИдентификатор - Уникальный идентификатор
//
// Возвращаемое значение:
//   Массив	- Массив (иерархический) содержит структуры
//
Функция DCRИзВременногоХранилища(АдресХранилища, УникальныйИдентификатор) Экспорт
	
	ФайлДвоичныеДанные = ПолучитьИзВременногоХранилища(АдресХранилища);
	
	ЧтениеТекста = Новый ЧтениеТекста(ФайлДвоичныеДанные.ОткрытьПотокДляЧтения());
	Текст = ЧтениеТекста.Прочитать();
	ЧтениеТекста.Закрыть();
	НовоеДеревоДанных = ЗначениеИзСтрокиВнутр(Текст);
	
	КорневойЭлементОтчеты = НовоеДеревоДанных.Строки[0];
	Данные = ПрочитатьДанныеDCR(КорневойЭлементОтчеты);
	ИТКВ_MCRФормат.ДополнительнаяОбработкаДанныхПослеЗагрузки(Данные, УникальныйИдентификатор);
	
	Возврат Данные;
	
КонецФункции

// Читает данные файла ERF из временного хранилища и помещает в иерархический массив структур
//
// Параметры:
//   АдресХранилища - Строка - Адрес временного хранилища содержащего данные 
//   УникальныйИдентификатор - УникальныйИдентификатор - Уникальный идентификатор
//
// Возвращаемое значение:
//   Массив	- Массив (иерархический) содержит структуры
//
Функция ERFИзВременногоХранилища(АдресХранилища, УникальныйИдентификатор) Экспорт
	
	ФайлERFДвоичныеДанные = ПолучитьИзВременногоХранилища(АдресХранилища);
	
	ПолноеИмяФайлаОтчета = ПолучитьИмяВременногоФайла("erf");
	ФайлERFДвоичныеДанные.Записать(ПолноеИмяФайлаОтчета);
	ТекстСхемыКомпоновкиДанных = ИТКВ_Конфигуратор.СхемаКомпоновкиДанныхИзВнешнегоОтчета(ПолноеИмяФайлаОтчета);
	УдалитьФайлы(ПолноеИмяФайлаОтчета);
	
	Данные = Новый Массив;
	НовыйЭлемент = Новый Структура;
	НовыйЭлемент.Вставить("Type", "DataCompositionSchema");
	НовыйЭлемент.Вставить("Text", ТекстСхемыКомпоновкиДанных);
	НовыйЭлемент.Вставить("Name", НСтр("ru = 'Схема компоновки данных'; en = 'Data composition schema'"));
	
	Данные.Добавить(НовыйЭлемент);
	
	ИТКВ_MCRФормат.ДополнительнаяОбработкаДанныхПослеЗагрузки(Данные, УникальныйИдентификатор);
	
	Возврат Данные;
	
КонецФункции

// Читает данные файла Q1C из временного хранилища и помещает в иерархический массив структур
//
// Параметры:
//   АдресХранилища - Строка - Адрес временного хранилища содержащего данные 
//   УникальныйИдентификатор - УникальныйИдентификатор - Уникальный идентификатор
//
// Возвращаемое значение:
//   Массив	- Массив (иерархический) содержит структуры
//
Функция Q1CИзВременногоХранилища(АдресХранилища, УникальныйИдентификатор) Экспорт
	
	ФайлXMLДвоичныеДанные = ПолучитьИзВременногоХранилища(АдресХранилища);
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.ОткрытьПоток(ФайлXMLДвоичныеДанные.ОткрытьПотокДляЧтения());
	НовоеДеревоДанных = ИТКВ_XML.ПрочитатьВДерево(ЧтениеXML);
	ЧтениеXML.Закрыть();
	
	КорневойЭлемент = НовоеДеревоДанных.Строки[0];
	Данные = ПрочитатьДанныеQ1C(КорневойЭлемент);
	ИТКВ_MCRФормат.ДополнительнаяОбработкаДанныхПослеЗагрузки(Данные, УникальныйИдентификатор);
	
	Возврат Данные;
	
КонецФункции

Функция ДанныеОтладкиИзСтрокиXML(СтрокаXML, УникальныйИдентификатор) Экспорт
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);
	
	Попытка
		
		ВходныеДанные = СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
		
	Исключение
		
		КраткоеПредставлениеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		ШаблонТекстаИсключения = НСтр("ru = 'Невозможно сформировать запрос из введенного XML, т.к. он, скорее всего некорректный.
                                       |Техническая информация: %1';
									   |en = 'It is not possible to form a query from the entered XML, because it is most likely incorrect.
                                       |Technical info: %1'");
		ТекстИсключения = СтрШаблон(ШаблонТекстаИсключения, КраткоеПредставлениеОшибки);
		
		ВызватьИсключение ТекстИсключения;
		
	КонецПопытки;
	
	ЧтениеXML.Закрыть();
	
	Данные = ПрочитатьДанныеОтладкиИзСтрокиXML(ВходныеДанные);
	ИТКВ_MCRФормат.ДополнительнаяОбработкаДанныхПослеЗагрузки(Данные, УникальныйИдентификатор);
	
	Возврат Данные;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ПрочитатьДанныеDCR(СтрокаДерева)
	
	Данные = Новый Массив;
	
	Для Каждого Строка Из СтрокаДерева.Строки Цикл
		
		ДанныеНовогоЭлемента = Новый Структура;
		
		Если Строка.ТипСтроки = 0 Тогда
			ТипСтроки = ИТКВ_Перечисления.ЭлементДанныхСхемаКомпоновкиДанных();
		ИначеЕсли Строка.ТипСтроки = 1 Тогда
			ТипСтроки = ИТКВ_Перечисления.ЭлементДанныхВариантОтчетаСКД();
		ИначеЕсли Строка.ТипСтроки = 2 Тогда
			ТипСтроки = ИТКВ_Перечисления.ЭлементДанныхПользовательскаяНастройкаСКД();
		КонецЕсли;
		
		ДанныеНовогоЭлемента.Вставить("Type", ИТКВ_MCRФормат.ЗначениеTypeВXML(ТипСтроки));
		ДанныеНовогоЭлемента.Вставить("Name", Строка.Имя);
		ДанныеНовогоЭлемента.Вставить("Text", Строка.Данные);
		ДанныеНовогоЭлемента.Вставить("Elements", ПрочитатьДанныеDCR(Строка));
		
		Данные.Добавить(ДанныеНовогоЭлемента);
		
	КонецЦикла;
	
	Возврат Данные;
	
КонецФункции

// Производит чтение данных из строки (Q1C формат)
//
// Параметры:
//  СтрокаДерева  - СтрокаДерева - Строка дерева
//
// Возвращаемое значение:
//   Массив - Данные
//
Функция ПрочитатьДанныеQ1C(СтрокаДерева)
	
	Данные = Новый Массив;
	
	Для Каждого Строка Из СтрокаДерева.Строки Цикл
		
		ДанныеНовогоЭлемента = Новый Структура;
		ДанныеНовогоЭлемента.Вставить("Type", "Query");
		ДанныеНовогоЭлемента.Вставить("Text", "");
		ДанныеНовогоЭлемента.Вставить("Parameters", Новый Соответствие);
		
		Если ТипЗнч(Строка.Значение) = Тип("Структура") Тогда
			Для Каждого Поле Из Строка.Значение Цикл
				
				Если Поле.Ключ = "name"
					ИЛИ Поле.Ключ = "text" Тогда
					Тип = Тип("Строка");
				КонецЕсли;
				
				ДанныеНовогоЭлемента.Вставить(ТРег(Поле.Ключ), XMLЗначение(Тип, Поле.Значение));
				
			КонецЦикла;
		КонецЕсли;
		
		Для Каждого ВложеннаяСтрока Из Строка.Строки Цикл
			
			Если ВложеннаяСтрока.Имя = "parameters" Тогда
				ДанныеНовогоЭлемента.Вставить("Parameters", Q1CЧтениеПараметровЗапроса(ВложеннаяСтрока));
			КонецЕсли;
			
		КонецЦикла;
		
		Данные.Добавить(ДанныеНовогоЭлемента);
		
	КонецЦикла;
	
	Возврат Данные;
	
КонецФункции

Функция Q1CЧтениеПараметровЗапроса(СтрокаДерева)
	
	ЗначенияПараметров = Новый Соответствие;
	
	Для Каждого Строка Из СтрокаДерева.Строки Цикл
		
		ДанныеПараметра = Строка.Значение;
		
		ЗначениеПараметра = Q1CЧтениеЗначенияПараметраЗапроса(Строка);
		
		Если ЗначениеПараметра <> Неопределено Тогда
			ЗначенияПараметров.Вставить(ДанныеПараметра.Name, ЗначениеПараметра);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ЗначенияПараметров;
	
КонецФункции

Функция Q1CЧтениеЗначенияПараметраЗапроса(СтрокаДерева)
	
	ДанныеПараметра = СтрокаДерева.Значение;
	ТипПараметра = ДанныеПараметра.Type;
	
	ЗначениеПараметра = Неопределено;
	Если ТипПараметра = "ТаблицаЗначений" Тогда
		
		ЗначениеПараметра = Q1CЧтениеЗначенияТаблицыЗначений(СтрокаДерева);
		
	ИначеЕсли ТипПараметра = "МоментВремени" Тогда
		
		ОписаниеМоментаВремени = СтрокаДерева.Строки[0].Значение;
		Ссылка = XMLЗначение(Тип(ОписаниеМоментаВремени.Type), ОписаниеМоментаВремени.ValueRef);
		Дата = XMLЗначение(Тип("Дата"), ОписаниеМоментаВремени.ValueDate);
		ЗначениеПараметра = ИТКВ_ОбщийВызовСервера.НовыйМоментВремени(Дата, Ссылка);
		
	ИначеЕсли ТипПараметра = "СписокЗначений" Тогда
		
		ЗначениеПараметра = Новый СписокЗначений;
		Для Каждого СтрокаПараметр Из СтрокаДерева.Строки Цикл // Блок Items
			ЗначениеПараметра.Добавить(Q1CЧтениеЗначенияПараметраЗапроса(СтрокаПараметр));
		КонецЦикла;
		
	Иначе
		
		ЗначениеПараметра = Q1CЧтениеЗначенияСТипом(ДанныеПараметра);
		
	КонецЕсли;
	
	Возврат ЗначениеПараметра;
	
КонецФункции

Функция Q1CЧтениеЗначенияСТипом(ДанныеЗначения, ОписаниеТипов = Неопределено)
	
	Значение = Неопределено;
	
	Если ОписаниеТипов = Неопределено Тогда
		
		ОписаниеТипов = Новый ОписаниеТипов(ДанныеЗначения.Type);
		Тип = Тип(ДанныеЗначения.Type);
		
	Иначе
		
		Тип = ОписаниеТипов.Типы()[0];
		ОписаниеТипов = ИТКВ_ТипыКлиентСервер.ОписаниеТиповПоТипу(Тип);
		
	КонецЕсли;
	
	Если ДанныеЗначения.Свойство("Value") Тогда
		Значение = XMLЗначение(Тип, ДанныеЗначения.Value);
	КонецЕсли;
	
	Возврат ОписаниеТипов.ПривестиЗначение(Значение);
	
КонецФункции

Функция Q1CЧтениеЗначенияТаблицыЗначений(СтрокаДерева)
	
	Колонки = Новый ТаблицаЗначений;
	Колонки.Колонки.Добавить("Имя");
	Колонки.Колонки.Добавить("Тип");
	Колонки.Колонки.Добавить("Длина");
	
	ЗначенияЯчеек = Новый Массив;
	
	Для Каждого СтрокаItem Из СтрокаДерева.Строки Цикл
		
		ДанныеЯчейки = СтрокаItem.Значение;
		ИмяКолонки = ДанныеЯчейки.nameCol;
		ДлинаТипаКолонки = ИТКВ_ОбщийКлиентСервер.Свойство(ДанныеЯчейки, "Length", 0);
				
		// Получаем данные колонки
		НайденнаяСтрока = Колонки.Найти(ИмяКолонки, "Имя");
		Если НайденнаяСтрока = Неопределено Тогда
			
			СтрокаКолонка = Колонки.Добавить();
			СтрокаКолонка.Имя = ИмяКолонки;
			ТипКолонки = Новый Массив;
			СтрокаКолонка.Тип = ТипКолонки;
			СтрокаКолонка.Длина = ДлинаТипаКолонки;
			
		Иначе
			
			СтрокаКолонка = НайденнаяСтрока;
			
			ДлинаТипа = НайденнаяСтрока.Длина;
			Если ДлинаТипа = 0 ИЛИ ДлинаТипаКолонки = 0 Тогда
				ДлинаТипа = 0;
			Иначе
				ДлинаТипа = Макс(НайденнаяСтрока.Длина, ДлинаТипаКолонки);
			КонецЕсли;
			СтрокаКолонка.Длина = ДлинаТипа;
			
			ТипКолонки = СтрокаКолонка.Тип;
			
		КонецЕсли;
		
		Если ТипКолонки.Найти(ДанныеЯчейки.Type) = Неопределено Тогда
			ТипКолонки.Добавить(ДанныеЯчейки.Type);
		КонецЕсли;
		
		// Получаем значения ячеек
		ОписаниеЯчейки = Новый Структура("ИндексКолонки, ИндексСтроки, Значение", Число(ДанныеЯчейки.Col), Число(ДанныеЯчейки.Row), Q1CЧтениеЗначенияСТипом(ДанныеЯчейки));
		ЗначенияЯчеек.Добавить(ОписаниеЯчейки);
		
	КонецЦикла;
	
	ТаблицаЗначений = Новый ТаблицаЗначений;
	Для Каждого Колонка Из Колонки Цикл
		
		Если Колонка.Длина = 0 Тогда
			КвалификаторыСтроки = Неопределено;
		Иначе
			КвалификаторыСтроки = Новый КвалификаторыСтроки(Колонка.Длина, ДопустимаяДлина.Фиксированная);
		КонецЕсли;
		
		ТаблицаЗначений.Колонки.Добавить(Колонка.Имя, Новый ОписаниеТипов(СтрСоединить(Колонка.Тип, ","), , КвалификаторыСтроки));
		
	КонецЦикла;
	
	Для Каждого ЗначениеЯчейки Из ЗначенияЯчеек Цикл
		
		Если ТаблицаЗначений.Количество() < (ЗначениеЯчейки.ИндексСтроки + 1) Тогда
			ТаблицаЗначений.Добавить();
		КонецЕсли;
		
		ТаблицаЗначений[ЗначениеЯчейки.ИндексСтроки].Установить(ЗначениеЯчейки.ИндексКолонки, ЗначениеЯчейки.Значение);
		
	КонецЦикла;
	
	Возврат ТаблицаЗначений;
	
КонецФункции

Функция ПрочитатьДанныеОтладкиИзСтрокиXML(Данные)
	
	Результат = Новый Массив;
	
	ДанныеНовогоЭлемента = Новый Структура;
	ДанныеНовогоЭлемента.Вставить("Name", НСтр("ru = 'Запрос'; en = 'Query'"));
	ДанныеНовогоЭлемента.Вставить("Type", "Query");
	
	// Текст запроса
	Текст = ИТКВ_ОбщийКлиентСервер.Свойство(Данные, "Текст", "");
	ДанныеНовогоЭлемента.Вставить("Text", Текст);
	
	// Значения параметров запроса
	ЗначенияПараметровЗапроса = Новый Соответствие;
	Параметры = ИТКВ_ОбщийКлиентСервер.Свойство(Данные, "Параметры");
	Если ЗначениеЗаполнено(Параметры) Тогда
		
		Для Каждого Параметр Из Параметры Цикл
			
			ЗначенияПараметровЗапроса.Вставить(Параметр.Ключ, Параметр.Значение);
			
		КонецЦикла;
		
	КонецЕсли;
	ДанныеНовогоЭлемента.Вставить("Parameters", ЗначенияПараметровЗапроса);
	
	Результат.Добавить(ДанныеНовогоЭлемента);
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти
